---
import Layout from '../../layouts/Layout.astro';

export async function getStaticPaths() {
	const posts = [
'building-tools-understand-whys-hows',
		'streamlining-blog-management-from-manual-edits-to-automation'
	];

	return posts.map((slug) => ({
		params: { slug },
	}));
}

interface Props {
	Astro: {
		params: {
			slug: string;
		};
	};
}

const { slug } = Astro.params;

// In a real app, you'd fetch this from a CMS or markdown files
const posts: Record<string, {
	title: string;
	date: string;
	content: string;
	tags: string[];
	readTime: string;
	author?: string;
}> = {
'building-tools-understand-whys-hows': {
		title: 'Building Tools to Understand the Why\'s and How\'s',
		date: '2025-08-12',
		readTime: '8 min read',
		tags: ['Learning', 'Development', 'Education', 'Tools'],
		content: `
			<p>There's a fundamental difference between knowing <em>how</em> something works and understanding <em>why</em> it works that way. Throughout my journey in cybersecurity and development, I've found that the best way to bridge this gap is by building tools yourself.</p>
			
			<h2>The Learning Problem</h2>
			<p>When you follow tutorials or use existing tools, you often learn the steps but miss the underlying principles. You might know that a certain API endpoint returns data, but do you understand why it's structured that way? You might know how to use a security tool, but do you understand the mechanisms it uses to detect threats?</p>
			
			<p>This gap between "how" and "why" becomes especially apparent when you need to troubleshoot, extend functionality, or adapt to new scenarios. That's why I started building my own tools—not just to solve problems, but to truly understand the systems I was working with.</p>
			
			<h2>Building the Python Security Toolkit</h2>
			<p>My Python Security Toolkit started as a way to understand security concepts at a deeper level. Instead of just using existing tools, I wanted to build domain analyzers, threat intelligence checkers, and file integrity tools from scratch. By implementing DNS lookups, WHOIS queries, and cryptographic hashing myself, I gained insights into how these systems actually work under the hood.</p>
			
			<p>When you write code to perform a DNS lookup, you're forced to understand the protocol. When you implement SHA256 hashing, you learn about cryptographic principles. When you build a threat intelligence checker, you understand how reputation systems function. These aren't abstract concepts anymore—they're real implementations you've created.</p>
			
			<h2>The Gamified Learning Side Project</h2>
			<p>Sometimes the best learning tools come from helping others. A friend of mine who's studying IT was struggling with memorizing network ports—a fundamental skill that's often taught through rote memorization. I thought there had to be a better way.</p>
			
			<p>That's how the port quiz in my security toolkit came to be. It wasn't part of my original plan, but it became a fun side project that gamified the learning process. Instead of staring at a list of ports and services, my friend could practice interactively, get immediate feedback, and track progress. The quiz turned a tedious memorization task into an engaging learning experience.</p>
			
			<p>What started as a way to help a friend ended up teaching me valuable lessons about user experience, educational design, and how gamification can make learning more effective. It also reinforced my belief that the best tools often come from real-world problems, not abstract requirements.</p>
			
			<h2>Why Building Beats Following</h2>
			<p>When you build your own tools, several things happen:</p>
			
			<ul>
				<li><strong>You encounter edge cases</strong>: Real-world scenarios that tutorials don't cover</li>
				<li><strong>You make mistakes</strong>: And learn from debugging them</li>
				<li><strong>You optimize</strong>: Understanding why certain approaches are faster or more secure</li>
				<li><strong>You adapt</strong>: Modifying code to fit specific needs teaches flexibility</li>
			</ul>
			
			<p>These experiences create a deeper, more durable understanding than any tutorial could provide. You're not just learning syntax—you're learning principles, patterns, and problem-solving approaches.</p>
			
			<h2>The Takeaway</h2>
			<p>If you want to truly understand something, build a tool around it. Whether it's a security scanner, a data analysis script, or even a simple quiz game, the act of creation forces you to think critically about the underlying concepts. You'll make mistakes, hit roadblocks, and spend time debugging—but each of these experiences adds to your understanding.</p>
			
			<p>The tools I've built aren't just projects for my portfolio. They're learning artifacts that represent my journey from "how does this work?" to "why does this work this way?" And that understanding is what makes the difference between following instructions and solving problems.</p>
		`
	},
	'streamlining-blog-management-from-manual-edits-to-automation': {
		title: 'Streamlining Blog Management: From Manual Edits to Automation',
		date: '2025-11-09',
		readTime: '4 min read',
		tags: ['Automation', 'Web Development', 'JavaScript', 'Node.js', 'Astro', 'Blogging', 'Developer tools'],
		content: `
<p>As web developers and content creators, we often find ourselves repeating mundane tasks. While the initial setup of a website might be exciting, the ongoing maintenance, especially for dynamic content like a blog, can quickly become a time sink. Today, I'm delving into a fascinating journey of how I tackled this challenge head-on, transforming my manual, error-prone blog management system into an elegant, automated solution.</p>
			
			        <h2>The Genesis of a Problem: Manual Blog Post Uploads</h2>
			        <p>The story begins with a common scenario: I was crafting my website's blog section. My initial step involved a basic HTML script, designed to simplify the creation of new blog posts. This script was quite ingenious for its time, providing a visual interface where I could input a title, date, tags, read time, a summary, and the blog's content. On the right, a live preview ensured the post looked exactly as I intended. Once satisfied, a button would export the necessary code.</p>
			        <p>However, the journey from exported code to a live blog post was still fraught with manual intervention. I remember the steps required for each new entry:</p>
			        <ol>
			            <li>Copying the first code block into the <code>posts</code> array in <code>src/pages/blog.astro</code>.</li>
			            <li>Adding the slug string from the second code block to the <code>posts</code> array within <code>getStaticPaths()</code> in <code>src/pages/blog/[slug].astro</code>.</li>
			            <li>Integrating the third code block into the <code>posts</code> object in <code>src/pages/blog/[slug].astro</code>.</li>
			        </ol>
			        <p>While the HTML editor did most of the heavy lifting, these manual edits, repeated for every new blog post, quickly became a source of frustration. After just a few posts, the time I wasted on these repetitive tasks became apparent, sparking the idea for a more efficient solution.</p>
			
			        <h2>Introducing <code>add-blog-post.js</code>: The Automation Catalyst</h2>
			        <p>The solution arrived in the form of a Node.js script I named <code>add-blog-post.js</code>. I designed this tool to eliminate the manual steps outlined above. Originally, it worked by taking a blog post in JSON format (saved directly from my HTML editor with a new "Save as JSON" button) and automatically performing all the necessary updates to the website's source code.</p>
			        <p>The workflow became dramatically simpler: once the JSON file was saved, a simple command like <code>node add-blog-post.js blog-post-test.json</code> would handle the rest, integrating the new post into the blog without any further manual intervention. This marked a significant leap forward, allowing me to focus more on content creation and less on the mechanics of publishing.</p>
			        <p>Here's a conceptual look at what the original command might have looked like:</p>
			        <pre><code>node add-blog-post.js blog-post-test.json</code></pre>
			        <p>This automation greatly reduced the overhead associated with blog publishing, making the entire process smoother and more enjoyable for me.</p>
			
			        <h2>Conquering the Reverse: Removing Blog Posts with <code>remove-blog-post.js</code></h2>
			        <p>With the adding process streamlined, the next logical hurdle was managing the removal of old blog posts. As with adding, removing posts involved a reverse set of manual edits. Recognizing this, I set out to create <code>remove-blog-post.js</code>.</p>
			        <p>Initially, this script mirrored its counterpart, requiring a command like <code>node remove-blog-post.js blog-post-example.json</code>. However, a crucial challenge emerged: remembering the exact slug for each post. While I could always dive into the source code, this was, by definition, manual work - precisely what I was trying to avoid.</p>
			        <p>Driven by my love for automation, I enhanced <code>remove-blog-post.js</code>. The improved version now automatically scans the blog section of the website's source code, presenting a list of all existing blogs in the terminal. This elegant UI allows for easy selection of the blog post to be removed, eliminating the need to recall or look up slugs. This user-friendly interface was so successful that I subsequently integrated it into <code>add-blog-post.js</code> as well, further simplifying the adding process.</p>
			        <p>The result is a powerful trio of tools: the HTML Blog Post Editor, <code>add-blog-post.js</code>, and <code>remove-blog-post.js</code>. These tools collectively empower me to effortlessly manage my blog content. 
			        
			        It's truly inspiring to see how a little bit of coding can save so much time and effort. This iterative approach to tool development is a testament to the power of identifying bottlenecks and proactively building solutions. Here's a visual representation of how these tools work together:
			        </p>
			        
			        <p>
			        
			        </p>
			        
			        <h2>The Road Ahead: A Glimpse into Future Enhancements</h2>
			        <p>With the current system for adding and removing posts firmly in place, I'm already looking to the future. The next tool I envision is a "blog editor" of sorts, aimed at facilitating easy modification of already-posted blogs. This ongoing commitment to automation and efficiency promises even more streamlined content management in the future.</p>
			        <p>The journey of building these tools serves as an excellent reminder: identifying repetitive tasks and investing time in automation can lead to significant long-term gains in productivity and enjoyment. As I like to say, "Stay curious." This mantra perfectly encapsulates the spirit of innovation that drives such useful creations.</p>
			        <p>Thank you for reading, and have a wonderful day!</p>
		`
	}
};

const post = posts[slug];

if (!post) {
	return Astro.redirect('/blog');
}
---

<Layout title={`${post.title} - Tyler Pauley`}>
	<article class="post-page">
		<div class="container">
			<header class="post-header">
				<a href="/blog" class="back-link">
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<path d="M19 12H5M12 19l-7-7 7-7"></path>
					</svg>
					Back to Blog
				</a>
				<div class="post-meta">
					<time datetime={post.date} class="post-date">
						{new Date(post.date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
					</time>
					<span class="post-read-time">{post.readTime}</span>
				</div>
				<h1 class="post-title">{post.title}</h1>
				<div class="post-tags">
					{post.tags.map((tag) => (
						<span class="post-tag">{tag}</span>
					))}
				</div>
				<div class="post-author">
					<span class="author-label">By</span>
					<span class="author-name">{post.author || 'Tyler Pauley'}</span>
				</div>
			</header>
			<div class="post-content" set:html={post.content} />
		</div>
	</article>
</Layout>

<style>
	.post-page {
		padding: 4rem 2rem;
		min-height: 80vh;
	}

	.container {
		max-width: 800px;
		margin: 0 auto;
	}

	.back-link {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		color: var(--color-text-muted);
		text-decoration: none;
		font-weight: 500;
		margin-bottom: 2rem;
		transition: color 0.2s;
	}

	.back-link:hover {
		color: var(--color-accent);
	}

	.post-header {
		margin-bottom: 3rem;
	}

	.post-meta {
		display: flex;
		gap: 1rem;
		align-items: center;
		margin-bottom: 1rem;
		flex-wrap: wrap;
	}

	.post-date {
		font-size: 0.875rem;
		color: var(--color-text-muted);
		font-family: 'JetBrains Mono', monospace;
	}

	.post-read-time {
		font-size: 0.875rem;
		color: var(--color-text-muted);
	}

	.post-title {
		font-size: clamp(2rem, 5vw, 3rem);
		font-weight: 700;
		line-height: 1.2;
		margin-bottom: 1.5rem;
		color: var(--color-text);
	}

	.post-tags {
		display: flex;
		gap: 0.5rem;
		flex-wrap: wrap;
	}

	.post-tag {
		background: var(--color-surface-elevated);
		border: 1px solid var(--color-border);
		padding: 0.375rem 0.875rem;
		border-radius: 6px;
		font-size: 0.875rem;
		color: var(--color-text-muted);
	}

	.post-author {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		margin-top: 1.5rem;
		padding-top: 1.5rem;
		border-top: 1px solid var(--color-border);
	}

	.author-label {
		color: var(--color-text-muted);
		font-size: 0.875rem;
	}

	.author-name {
		color: var(--color-text);
		font-weight: 600;
		font-size: 0.875rem;
	}

	.post-content :global(*) {
		color: var(--color-text);
		line-height: 1.8;
		font-size: 1.125rem;
	}

	.post-content :global(h2) {
		font-size: 2rem;
		font-weight: 600;
		margin-top: 3rem;
		margin-bottom: 1.5rem;
		color: var(--color-text);
	}

	.post-content :global(h3) {
		font-size: 1.5rem;
		font-weight: 600;
		margin-top: 2.5rem;
		margin-bottom: 1.5rem;
		color: var(--color-text);
	}

	.post-content :global(p) {
		margin-bottom: 1.75rem;
		color: var(--color-text-muted);
	}

	.post-content :global(code) {
		background: var(--color-surface-elevated);
		border: 1px solid var(--color-border);
		padding: 0.125rem 0.5rem;
		border-radius: 4px;
		font-family: 'JetBrains Mono', monospace;
		font-size: 0.9em;
		color: var(--color-accent);
	}

	.post-content :global(pre) {
		background: var(--color-surface-elevated);
		border: 1px solid var(--color-border);
		border-radius: 8px;
		padding: 1.5rem;
		overflow-x: auto;
		margin: 2.5rem 0;
	}

	.post-content :global(pre code) {
		background: none;
		border: none;
		padding: 0;
		color: var(--color-accent);
		font-size: 0.95em;
	}

	.post-content :global(a) {
		color: var(--color-accent);
		text-decoration: none;
		border-bottom: 1px solid transparent;
		transition: border-color 0.2s;
	}

	.post-content :global(a:hover) {
		border-bottom-color: var(--color-accent);
	}

	.post-content :global(ul),
	.post-content :global(ol) {
		margin: 2rem 0;
		padding-left: 2rem;
	}

	.post-content :global(li) {
		margin-bottom: 1rem;
		color: var(--color-text-muted);
		line-height: 1.8;
	}

	.post-content :global(em) {
		font-style: italic;
	}

	.post-content :global(strong) {
		font-weight: 600;
		color: var(--color-text);
	}

	@media (max-width: 768px) {
		.post-page {
			padding: 3rem 1.5rem;
		}
	}
</style>

